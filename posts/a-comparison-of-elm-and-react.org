#+title: A comparison of Elm and React (in code) 
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="style.css" />
#+date: 2017-01-22

#+begin_html
  <p>
#+end_html


Since React's open source release in 2013, techniques inspired by
functional programming have become an integral part of what many
consider 'best practice' in front-end application development on the
web. Functional programming as a concept has been around since the
lambda calculus was invented to study computation in the 30s, and it
became practicable through Lisp in 1958, and then further through ML in
the 70s. Only now, however, is it finding its way into the mainstream.
This post investigates functional techniques in contemporary 'best
practice' front-end development by comparing an application in Elm to
its equivalent in React.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Disclaimer: I think Elm is a lot more expressive and robust than the
React equivalent.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

What follows is a 'translation' of Elm's syntax to its React equivalent,
demonstrating what abstractions are shared between the programming
dialects. By contextualizing the approach of each framework within the
web's history and the JS ecosystem, I argue that Elm offers a more
concise and expressive syntax for than the 'best practice' React
application, as both frameworks are intended to be used through the same
architectural primitives. In addition, I also provide brief reviews of
JS frameworks that employ a similar architecture (which I'll simply
refer to as the 'Elm architecture' from this point on), comparing them
to Elm and pointing at how Elm is more concise and expressive in
comparison, in the same way that it is for React.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

In order to clearly compare React and Elm, I've made a very simple
'books' front-end interface that makes an HTTP request, and visualises
the returned JSON data (which represents some of the books I've read in
the last couple of months). The code for these applications, as well as
instructions to run them, are available in the folders elm-books and
react-books in the following repo:

#+begin_html
  </p>
#+end_html

#+begin_html
  <p style="text-align:center;">
#+end_html

github.com/breezykermo/react-elm-books

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

When referencing code in the following post, I'll refer to a set of line
numbers and the file in which the code can be found, implying the
appropriate directory through the filetype. For example, the reference
[1-12 Main.elm] refers to lines 1 through 12 in file the file
elm-books/src. Alternatively, [2,6-8 App.js] refers to line 2 and lines
6 through 8 in the file react-books/src. Links to the relevant code in
Github will be provided as they are here.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h2>
#+end_html

Background: React

#+begin_html
  </h2>
#+end_html

#+begin_html
  <p>
#+end_html

The composition of components in a tree is an intuitive architecture for
view interfaces, and some variation of it is implemented on almost every
modern application platform that supports a UI. The browser, for
example, constructs its view through a tree of HTML nodes. The iPhone
and Android platforms use tree-based abstractions such as Views and View
Managers to handle the pixels they render on-screen. The application as
a whole is usually composed as one large 'layout' component that nests
several child components (e.g. header, body, footer), each of which in
turn may nest their own child components, and so on.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

In the browser's case, the tree of HTML nodes is represented as a data
structure in the JS runtime. This structure is called the Document
Object Model, more commonly referred to by its acronym, the DOM. The
HTML view can be adjusted by modifying the DOM in the JS runtime, and
these DOM updates are then transmitted to the actual HTML component
tree. Modifying the HTML through the DOM is relatively computationally
expensive, as the web was built on the premise of serving static
documents, with JS and the DOM (i.e., the browsers utilities that allow
dynamic updates) only added later. It is much less taxing on the browser
to run JS that does not access or modify the DOM.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

We have come to expect much more of the web than static documents
in 2017. In the popular imagination, many complex websites are conceived
as analogues of native application platforms such as iOS and Android,
and are expected to provide the same quality of interactivity and
interface. This type of interactive web page is now known as a
single-page application (SPA). There is an enormous collection of JS
libraries that provide developers with utilities to manage DOM updates
at higher levels of abstraction, and more intuitively. The most widely
used of these is jQuery, which is a flexible collection of functions
that access and update DOM nodes with an arguably more intutive syntax
than the base DOM API. In many cases, a library will provide both a
strongly opinionated toolkit (collection of functions and classes) for
managing the DOM, and also one or more practicable development
strategies which promote particular abstractions for managing
complexity. We may call these strategic libraries frameworks.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

A successful framework insulates the developer from the DOM's
technicalities, and allows her to architect an application on higher
level primitives than those that the DOM provides. For example, Angular
1.x, maybe the most popular full-bodied framework of the last 5 or 6
years, provides abstractions such as controllers and two-way data
binding, along with many others, to allow the developer a
Model-View-Controller (MVC) architecture for her applications.
Controllers manage a certain scope of DOM nodes and their updates, and
two-way data binding facilitates connecting one state of the screen to
another state, for example the value of an input node to the text in an
h3 tag.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

There has recently been a revision in the philosophy of DOM access used
by many JS frameworks in the ecosystem. In 2013, Facebook open-sourced a
JS framework called React, which was being used internally at Facebook.
React has since enjoyed widespread adoption as a front-end framework in
the tech industry. This crusade is led by its extensive use at
well-respected companies like Facebook and Airbnb.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

React's core design principle is stated on its website: "the key feature
of React is the composition of components." While frameworks like
Angular 1.x were pitched as a holistic framework for the browser, where
almost every conceivable part of the application--view declaration,
state management, routing, dependency injection, and much more--is
handled in some way by the framework, React declares itself only as a
way to "build encapsulated components that manage their own state, then
compose them to make complex UIs." It does not strictly opinionated
other essential aspects of the SPA, and this flexibility is one of the
reasons for its popularity. As I will make clear in later sections,
however, despite its interoperability with many types of development,
React is designed with an a particular 'holistic' SPA architecture in
mind.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The primary way in which React differs from frameworks like Angular 1.x
is in the way that it registers and performs updates to the DOM. The SPA
is constantly updating different parts of the DOM, handling side effects
such as user input and asynchronously delivered data. In a typical SPA,
there are thousands of nodes in the DOM tree. When we recall that the
DOM is really optimised for one-time render of documents, not an
application of changing frames that updates constantly, it is evidently
important that a framework for the browser be economical in the way that
it performs DOM updates.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

As the complexity of applications on the web like Facebook increased,
they discovered that "in our sufficiently large codebase, in our
sufficiently large company, MVC [gets] really complicated, really
quickly [for developers]." The cause of this complexity was the free,
decentralised way in which updates to the DOM were being made, and the
fact that the application state was distributed across the app in
various different sections. As there were a lot of developers working on
the codebase, it was very difficult for an individual developer
understand exactly what was going on in the part of the application they
were working on, because:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

The section was able to be modified by other parts of the application.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

It was very difficult to identify these modifications statically in the
code, and even when they were happening in real time it was not always
easy to trace which code or event had triggered the change.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

Facebook's solutions to these problems were:

#+begin_html
  </p>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li>
#+end_html

Enforcing a single direction in which data can conceptually 'flow'
through components for updates: down through the tree of nodes from the
top.

#+begin_html
  </li>
#+end_html

#+begin_html
  <li>
#+end_html

A central location where all actions relevant to a section of the
application are registered, so that all events are traceable.

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  <p>
#+end_html

However, unidirectional data flow (Facebook's first solution) in a
browser SPA is not an immediate solution. In unidirectional data flow,
all updates exclusively enter from the top node of the DOM tree, and
propagate down through child components. By this method, the entire
application needs to re-render on every change. Given that it is
computationally expensive to access the DOM via JS, this kind of
complete re-render is super expensive.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Through what is essentially a very clever hack, React provides
developers with the abstraction of unidirectional data and keeps updates
performant through the use of a virtual DOM. The virtual DOM is a
virtual representation of the actual DOM that is much less expensive to
modify, as it does not actually re-render the HTML nodes. With a virtual
DOM, React only has to perform its re-render virtually, which is a
relatively inexpensive operation. Using a clever diffing algorithm,
React then calculates the necessary changes in the real DOM, and then
performs those changes without having to re-render the entire real DOM.
React's diffing algorithm is, as it notes in its documentation, "an
implementation detail. React could re-render the whole app on every
action; the end result would be the same." React's performant diffing
algorithm is this crucial optimization that allows React to compete in
performance with frameworks that directly manipulate the DOM, while
mantaining the beneficial abstraction of unidirectional data for the
developer's peace of mind.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

At the same time that Facebook released React, they also released Flux,
an "application architecture for building user interfaces." Flux
provides state management abstractions that operate well in tandem with
React components, as the library is also built around the virtues of
functional programming, more specifically immutable data and
unidirectional data flow. As John Reppy calls the JS event loop "a poor
man's concurrency" in his book "Concurrent ML", the Flux architecture
might be considered a poor man's monad. Flux uses stores to represent
application state, and flushes this state through a view tree hierarchy
(e.g., a network of React components). Modifications to the stores may
be made through a set of pre-defined actions, and the stores then emit a
change event, to which views (i.e. React components) may subscribe. A
library called Redux has become a popular alternative to Flux, as it
essentially provided the same beneficial architecture through more
powerful functional abstractions. Most notably, it reduces the burden on
the developer of managing store subscriptions (a complexity that the
developer has to deal with in Flux). In Redux, changes to a store
trigger an automatic refresh of the view tree, and the refresh is made
efficient by use of the virtual DOM in React.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The creator of Redux, Dan Abramov, was explicitly taking cues from the
Elm architecture in order to reduce the conceptual complexity of Flux. I
will be using Redux alongside React to express the Elm architecture, as
React does not provide sufficient abstractions on its own. I will also
be using some additional libraries with React and Redux to more
expressively mirror the Elm architecture. Immutable.js allows the
creation and management of 'immutable' objects in JS, which we will use
in order to keep 'immutable' state in the Redux store. This allows for a
more performant update of a large store. Redux-thunk is a library
authored by Dan Abramov himself, which allows controlled dispatch of
asynchronous actions to the Redux store. I will explain more about how
these libraries work as they are used in the examples below.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h2>
#+end_html

Foreground: Elm

#+begin_html
  </h2>
#+end_html

#+begin_html
  <p>
#+end_html

Though Facebook popularised the notion of unidirectional data flow in
the browser through React, they by no means invented it. Nor were they
necessarily the first to apply it to web's domain through the virtual
DOM. The idea of unidirectional data as an effective paradigm for state
management is, in fact, an idea taken from the functional programming
community. In purely functional programs, unidirectional data flow is
implicit. There is no conception of 'two-way' data as there is in
object-oriented programming; programs declaratively produce a result
from a given input. In other words, purely functional programs are
nothing more than simply referentially transparent functions that take
an input and produce a value deterministically. Reducers, the mechanisms
that manage updates in the Redux paradigm, are referentially transparent
functions that take an input and produce a value deterministically.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Elm is a functional language written by Evan Czaplicki for his senior
thesis at Harvard in 2012 that was designed as a more robust way of
developing GUIs for the browser. Programs are written in its own syntax,
and the Elm compiler then produces browser-ready HTML, CSS and JS. As
Czaplicki explains in his thesis, "the core language of Elm combines a
basic functional language with a small set of reactive primitives",
where "reactive primitives" come from the domain of programming known as
functional reactive programming (FRP). Inspired by techniques in
functional concurrent languages such as CML, Elm provides the programmer
with view abstractions directly comparable with those in React (it also
uses a virtual DOM), as well as an elegant and robust approach to
management in synchronous updates, data validation, and asynchronous
requests. Elm has been actively maintained and developed by Czaplicki
since 2012, initially at Prezi from 2013, and now at NoRedInk. Both of
these companies actively use Elm in production.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h3>
#+end_html

Component Tree

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

As I have noted, both React and Elm make use of a virtual DOM in order
to allow the conceptual re-render of the entire application at each
change, while remaining performant in the update context of the DOM. One
way in which both frameworks do this is by avoiding the re-computation
of pure functions with unchanged inputs. Elm's concurrent runtime system
uses memoization to do exactly thiss. React's 'reconciliation'
algorithm---the algorithm React uses to diff the virtual DOM with the
DOM---employs a similar technique. This is possible because the
functions are deterministic: given an input, they always produce the
same output. Though the virtual DOM/DOM diff is conceptually the same in
both frameworks, Czaplicki demonstrates Elm's superior performance and
ease of optimisation in the elm-lang blog post, "Blazing Fast Html Round
Two."

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

In terms of their use, 'components' in Elm and React are very similar.
It is worth nothing that React has three types of components: legacy
components, ES6 components, and stateless functional components. The
last of these demonstrate the way in which React components can be
considered simply as functions [6-17 components / Desk.js]. The most
conspicuous difference between Elm and React components is the different
syntaxes of HTML markup. React, by convention, uses JSX, a syntactic
sugar that allows components to read like HTML elements. Elm, on the
other hand, uses a collection of functions, isomorphically named to suit
the full set of HTML tags available. Each of these functions takes in
two lists as arguments; the first is a list of attributes to be applied
to the node, and the second is a list of its nested children. These
functions are provided by the elm-lang / html library that ships with
Elm. This library also provides similar functions for the relevant
attributes that can be applied to each HTML DOM node, such as 'class'.
Both provide a functional map utility for lists of components [30,62
Main.elm][22 components/Desk.js], though React requires an added key
attribute that is unique from other keys in the containing list, as a
marker for its reconciliation algorithm.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Perhaps the most notable difference in component specification is the
way in which view data is validated. React allows the optional
specification of propTypes [14-16, 25-27 components/Shelf.js], which
will be performed as runtime checks on data that is passed into the
components, and which will throw a non-blocking error in the console if
the checks fail.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Let me quickly digress to talk about data validation in JS generally;
responsible manipulation of data in vanilla JS is largely up to the
developer. There are various JS utilities that address this concern in
JS, such as Flow and TypeScript. Flow is an optional static type checker
that can be inserted incrementally into a codebase, and TypeScript is a
Java-like superset of JS that is strongly typed. However, it is
difficult to use either of this tools fluidly with Immutable.js objects,
as both are designed to type check regular JS types, rather than
Immutable's transformed ones. Certain Immutable types, such as Records,
provide partial type checking, in that Records can restrict fields to a
certain shape. However they do not enforce strict types for the values
contained within the shape.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

In order to synthesise complete type checking in React, I am using a
combination of Immutable's shape enforcement, React's runtime propType
checking, and Flow's static type checking for functions. When data is in
the Redux store, it is validated through Immutable's incomplete type
assertions. When it reaches React, it is converted to JS (a relatively
expensive operation, it is important to note, especially for large
stores), and then validated in React components through PropTypes, and
in functions through Flow. Note also that type definitions need to be
repeated across Flow and React's PropTypes API, which violates the 'Do
not Repeat Yourself' principle of best practice development. If this
sounds complicated, it is because it is--type validation is no simply
feat in React.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Elm, on the other hand, validates data entirely through its type system.
As a strongly typed language, Elm will complain at compile time if the
wrong arguments are passed to a function, or if data is used
irresponsibly in components or elsewhere. Note that the type alias Book
is used in function signatures [29,42,62 Components/Pure.elm]. Type
aliases allow the programmer to define their own custom records for
elegant function types such as, shelfDisplay : Book -> Html msg. This
solution is noticeably both more robust and more elegant than the
partial runtime type-checking I have synthesised in React.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h3>
#+end_html

Synchronous Updates

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

In both Elm and Redux, synchronous updates in the view occur reactively.
Data expressing the application state is kept in an immutable structure
separate from the view tree. Each time the structure is reproduced, the
view tree re-renders through a virtual DOM diff. In Elm the structure is
called the model, and in Redux it is called the store.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Elm's update function works by restructuring a Msg that possibly
contains data, and produces a new model by addressing the previous model
from this Msg [37-43 Main.elm]. Redux sends actions to the store, which
are generated by action creator functions [21-25, 27-31 reducers.js]. A
delivered action reproduces the store's structure through a reducer
function [33 reducers.js], which combines the action and its associated
data and with the previous state, generating a new structure. Note that
in Redux's reducer, immutable data is not enforced by default, only
strongly recommended, though I enforce it by only storing data in the
store the Immutable library [38,39 reducers.js] . I have chosen to use
regular JS objects outside the store, for the reason explained above of
using Flow to statically type check function arguments.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h3>
#+end_html

Async

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

Elm's update function also returns an optional cmd [34-52 Main.elm] . A
cmd allows Elm to perform side effects in its otherwise purely
functional environment. Side effects include generating random numbers,
and making server requests. When creating the model through the init
function [15 Main.elm] , Elm allows an initial cmd to be executed [22
Main.elm] . Cmds can then send Msgs to the update function after
completing a side effect, for example a NewShelf msg after making an
HTTPS request. The cmd is not executed when it is created [66-68,
Main.elm], it is only executed when it is passed through the update
function [34 Main.elm].

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Redux-thunk enriches Redux with an analogue of Elm's cmds, which it
calls 'thunks'. Thunks are action creators that return a curried
function (rather than a JS object), which is then applied at the
threshold of the store by middleware [11 index.js]. The middleware
passes the function a dispatch function, so that the thunk can send its
own actions to the store, and a getState function, which returns the
store's state at a given time.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h3>
#+end_html

Validating JSON

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

Because Elm is strongly typed, values that arrive in JSON cannot be used
directly. Elm provides a validation library called Json.Decode, and
Czaplicki's current company, NoRedInk, provides syntactic sugar in a
library called elm-decode-pipeline. Though this explicit decoding may
seem laborious to developers who are used to using JSON directly in JS,
it provides a data robustness that JS cannot achieve by itself. Many
runtime errors that occur in web applications are the result of dud or
mistyped data that the application has received from elsewhere, and thus
data validation at its entry point makes for a generally more robust
application. The Elm type system requires explicit handling of error
scenarios, which results in virtually no runtime errors that are the
fault of the front-end. (NoRedInk has been running Elm in production for
more than a year, and are yet to find a runtime error that traces back
to Elm code.)

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Creating a comparable validation mechanism in JS is possible, though it
is laborious to make the checking rigorous, and there is an added layer
of conceptual complexity. The developer has to handle the possibility of
null values, a complexity that Elm's decode libraries abstract through
the Result type. The formulation is decidedly less elegant in JS
[decoder.js] [Decoders.elm] . (Note: there is possibly a more robust JS
data validation library of this sort out there, please let me know if
you know of one!)

#+begin_html
  </p>
#+end_html

#+begin_html
  <h3>
#+end_html

Extra Comments

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

Elm also provides reactive subscriptions to values that vary over time,
which are similar to streams in functional programming. These are a very
useful higher level abstraction in Elm, and make it easy to create
interfaces such as Kris Jenkins' 'Rays'. I have not implemented
subscriptions in JS, though it would be possible to do so through a
library such as RxJS, or Ractive.js. This is an interesting project that
I haven't looked at in depth.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h3>
#+end_html

Other Libraries

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

React is largely responsible for popularizing a component architecture
with unidirectional data flow, as Facebook's standing as a prestigious
company encouraged many developers to practice web development with the
framework (myself included). There are now a range of different
libraries that employ this architecture in the JS ecosystem, each of
which offers a slightly different angle on the Elm architecture. In this
section, I review some of the more interesting libraries in this
ecosystem, briefly comparing them to Elm.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h5>
#+end_html

Choo

#+begin_html
  </h5>
#+end_html

#+begin_html
  <p>
#+end_html

Choo is a framework that provides the Elm architecture in a syntax that
much more closely resembles vanilla JS. Choo's API is almost completely
isomorphic with Elm's. Choo notes its point of difference in its readme:
"contrary to elm, choo doesn't introduce a completely new language to
build web applications." It uses a virtual DOM to perform updates, and
employs a component architecture in templated HTML strings, rather than
through a custom library (Elm) or JSX (React). It does not provide JSON
decoding support.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h5>
#+end_html

Vue

#+begin_html
  </h5>
#+end_html

#+begin_html
  <p>
#+end_html

Vue provides components to create a view interface, and its own library
for unidirectional data flow called Vuex. This is very similar to Redux,
though it places a greater emphasis on reactivity. However, Vue does not
restrict the developer to this unidirectional data architecture, and it
also provides many Angular 1.x features, such as two-way data binding.
It provides support for TypeScript, though there are some types that
this integration cannot infer. Vue suggests using HTML templates for its
view syntax, which look like normal HTML with some extra Vue attributes
on certain elements. It also supports JSX. It does not provide JSON
decoding support.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h5>
#+end_html

Angular 2

#+begin_html
  </h5>
#+end_html

#+begin_html
  <p>
#+end_html

Angular 2 is a remake of Angular 1.x using components as the core
abstraction. Its API is very similar to React, though it is modelled as
an all-purpose framework for creating front-ends, rather than only
providing the view, and is a lot bulkier. Angular 2 does not opinionate
your state management, much like React. It is possible to implement an
application with Elm architecture through ngrx's 'store' library, which
is inspired by Redux. Angular 2 enforces use of TypeScript, and as a
result is strongly typed. It does provide JSON decoding support, but it
is not strictly typed on all values, as Elm is.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h3>
#+end_html

Elm as React/Redux generator

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

I was interested to see if it would be possible to automatically
generate a React-Redux application from Elm code, to provide a general
solution for creating a React-Redux analogue from an Elm program. This
was always going to be mostly an intellectual exercise, as this
generator would have dubious utility. As I have shown, Elm applications
are more concise, generally more expressive, and more performant than
React-Redux applications. Elm enables interop with JS through a language
feature called ports, which allow the developer to use external JS
libraries by sending necessary values directly to the Elm runtime.
Because Elm is interopable with JS, there is no argument for React on
the grounds that it has access to a better ecosystem in JS (an argument
that often kills web application frameworks that are not written in JS).
For me, Elm is an almost categorically better conceptual toolkit for
creating robust front-end applications.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

An Elm generator would only be usable if your developers already knew
Elm, and if that were the case there would be no reason why you wouldn't
just use Elm's compiled output in production. The only practical way a
generator might be useful would be in the context of pedagogy. As more
developers are familiar with React and Redux than Elm, a systematic way
of mapping between Elm and React-Redux programs might provide a valuable
learning resource for developers looking to learn Elm from React-Redux
(or vice-versa).

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The Elm compiler and most of its associated tooling is written in
Haskell, and is available publicly on Github. The compiler operates
through the command line tool called elm-make, which takes an Elm file
and generates browser-ready JavaScript. Although I was came to
understand a lot about the elm-compiler and elm-make codebases, I found
it very difficult working efficiently with Haskell's package and build
manager, cabal. Simple modifications to the codebase can take minutes to
build, and as Haskell is strongly typed, I found myself running into
type errors simply trying to print values and find my bearing. For these
reasons, I was not able to successfully modify the compiler to produce a
React-Redux application from an Elm source. However, in the following
section, I offer what insights and tools I produced through my
investigation of Elm's source code.

#+begin_html
  </p>
#+end_html

#+begin_html
  <h4>
#+end_html

Elm Env

#+begin_html
  </h4>
#+end_html

#+begin_html
  <p>
#+end_html

In order to get the elm compiler running from source on my computer, I
ran the appropriate installations in a Docker container. Docker is a
containerisation platform that provides a system of containers, which
can be thought of as light-weight virtual machines. Containers are built
from images, which are snapshots of a container's starting state. I have
created a public Docker image for a container in which you may develop
and build new versions of the Elm source code. See the following
repository for details:

#+begin_html
  </p>
#+end_html

github.com/breezykermo/elm-env

#+begin_html
  <h4>
#+end_html

Elm Compiler Docs

#+begin_html
  </h4>
#+end_html

#+begin_html
  <p>
#+end_html

Though I was not able to produce a custom generator for the elm-make
interface, I learned a lot about the elm-make and elm-compiler
codebases, in particular the means by which it generates JS from an Elm
program. I have submitted much of what I learned as a pull request to
the elm-compiler-docs repository, a resource for the Elm community that
aspires to document the Elm compiler, independent of its creator and
maintainer. This is useful for future contributors, as wrapping one's
head around a large codebase is a considerate barrier to entry. It is
also useful reference for those looking to create a compiler in Haskell,
as the Elm code provides a very good example of how Haskell can be used
effectively. The PR can be found at the following repo:

#+begin_html
  </p>
#+end_html

github.com/elm-community/elm-compiler-docs

#+begin_html
  <h4>
#+end_html

Elm Make Generators

#+begin_html
  </h4>
#+end_html

#+begin_html
  <p>
#+end_html

In addition to the above documentation, I have also created a separate
repository with preliminary information on how to generate a custom
'elm-make' generator. The elm-compiler and elm-make codebases are
wonderful resources for learning about Elm and compilers, as they
provide a robust demonstration of how one language might compile to
another. Further work here might involve coding generators for a range
of different JS frameworks that use the Elm architecture---though I
suggest this with the same disclaimer as I did the React-Redux
generator; its primary use-case would most probably be as a learning
resource.

#+begin_html
  </p>
#+end_html

github.com/breezykermo/elm-make-generator

#+begin_html
  <h3>
#+end_html

Works Cited

#+begin_html
  </h3>
#+end_html

#+begin_html
  <p>
#+end_html

Reply, John H. Concurrent Programming in ML. Cambridge: Cambridge U
Press, 1999. Print.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Czaplicki, Evan. Elm: Concurrent FRP for Functional GUIs, 30 March 2012.
https://www.seas.harvard.edu/sites/default/files/files/archived/Czaplicki.pdf
accessed 01/09/17.

#+begin_html
  </p>
#+end_html
