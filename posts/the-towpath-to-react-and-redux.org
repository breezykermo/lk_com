#+begin_html
  <p>
#+end_html

When you visit a URL, you are redirected through the internet to a
server somewhere in the world, and code is triggered on that server,
prompted by your request. Sometimes that code makes requests elsewhere,
retrieving other resources from a database or elsewhere before returning
files to your browser, which we can call the client, that made the
request. This is how the Facebook page that you see when you visit
facebook.com is different from your friends'. Even though you could both
be at the same URL; the page is customized at the server-side before it
is returned to your browser through the login parameters that you sent.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

In simpler sites, such as lachlankermode.com1, when there are no
required exterior resources and no customization, the server simply
directly returns HTML, CSS and Javascript files to your browser.
Browsers have been programmed to interpret these filetypes. They know
how to render in color and glory the wonderful web pages that we can
browse on the internet. This was really the paradigm in which the web
was originally designed; it was built as a forum for the retrieval and
consequent display of HTML documents.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

However, we have come to expect much more of the web in 2016. Sites
ought to be dynamic, viewable and beautiful from many different shapes
and sizes of device, and they should interactively update based on where
I click, swipe and hover. Back in 1994, Brendan Eich created Javascript
at Netscape. Javascript was conceived to run in the browser on the
client side to make the experience of the web more dynamic: through
Javascript, the browser could partially update and modify HTML documents
in response to events, such as clicks and hovers. Event handlers in
Javascript could also asynschronously request resources across the web,
read and write to the user's local file system, among many other
capabilities.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Javascript's relationship with the original conception web of documents
is really the core of how the web works today. It enables the dynamic
experience of data and documents that we expect and encounter every time
we open a browser. The web is more than just an organically organized
global file cabinet; it is an enormous network of theatrical data
exhibitions that personally interact with each visitor, exhibitions that
communicate with each other in non-trivial ways.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

The web's origin and history are inscribed in its practice today. The
exhibitions we call websites are built on top of original document
structure of the web, and the friction between what the web was and what
it has become is keenly felt by those of us who develop on its platform.
Programming for browsers, which we can more technically call the
Document Object Model (or the DOM), is a matter of negotiating many
minute updates to an HTML document in response to a range of events, all
computed against the dimension of time3.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Libraries like jQuery emerged to provide ways of managing these updates
and manipulations, and they were soon followed by frameworks like
AngularJS and Backbone, which offer extensive suites replete with
solutions to the common and immediate complexities of developing with
the DOM in Javascript. Equipped with these tools, developers were able
to build softer, warmer single-page-application flesh around the web's
document bones. The experience of HTML in the DOM grew into the
performative and interactive showcase we know and adore day-to-day in
our quotidian rituals.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

But as applications like Facebook became larger and larger, and
increasingly complex, developers discovered that it was very hard to
keep track of everything that was being updated on each event.
Developers found that in attempting to change one thing, often something
that seemed simple and straightforward, they would routinely break some
other part of the system. In more complex applications, it was difficult
to know which events were being triggered where, or how exactly data was
being fed into the DOM.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

In this era of complexity, unidirectional data flow was born, pomaded by
a sexy midwife, React. The basic idea of unidirectional data flow is
explicitly simple: data should flow in one direction conceptually for
the developer, so that it is easy to keep track of. Updates to the DOM
ought to be administed one at a time, in a traceable way, and preferably
from one single source of truth, so that the range of updates and
insertions are transparent to the developer. Parts of the DOM should not
be able to reach out to a distant cousin of the DOM and change it
without telling anything else. React is a very popular library that
breaks up the view layer of an application into citizens that listens
for changes from some authority, and it calls these citizens components.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

A React component is rendered with a set of input values which are
called props. Each time the props for a component changes, the entire
component re-renders. In other words, a React component is a UI
expression of the data that is passed into it. When the input data
changes, the function is called again with the new data. React
components can call functions that make or request changes to an
external store, from which they then in turn receive their props. Data
flows in one direction, and can always be intercepted and explicitly
monitored in the application state4.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

React's conceptual simplicity is made performant through some very
clever way of hacking the DOM's core architecture. Because the DOM was
designed to render entire documents, it is not really very good at
making incremental changes to those documents, and therefore as
developers we want to limit DOM updates to those that are necessary; we
don't want to overwrite parts of the DOM with nodes to refresh entire
components in the DOM when only a small part of the UI has changed.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

React affords developers the conceptual benefit of full component
re-rendering, but also only makes necessary changes to the DOM by using
a virtual DOM. When a component's props change, the virtual DOM handles
the component re-render in a less computationally expensive virtual
arena, and then uses a clever diffing algorithm to determine which
specific updates need to be made in the real DOM. This wonderful
abstraction mediates between the developer's experience of application
development and the DOM's anatomical requirements.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

A core contributor to React's popularity in the web development
community is the canon of state management solutions that is conceived
alongside React itself; architectures for the external store to which
React components subscribe and from which they receive their props. The
most popular of these at the moment is Redux, a library written by Dan
Abramov inspired by techniques in Elm and other functional programming
languages. Redux offers a very robust architecture for managing the
external store in React applications.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

Redux popularity skyrocketed after Dan Abramov demonstrated what was
possible in the way of developer tools--explicit changelogs, hot
reloading, and even time travel. Redux became the most popular Flux
implementation, Facebook's suggested solution for managing state in
React applications. One of the keys to Redux's popularity is its
extensibility. It is an architecture for state management, not an
already constructed building you have to drop into your application.
Managing updates to the store from asynchronous data sources, for
example, is not a prebuilt capability in Redux, it rather has several
possible solutions.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

React's ethos of hacking existing anatomy to ease cognitive burden for
the developer is unsurprisingly popular in the developer community, as
it makes programming applications easier and, more importantly, more
fun. This ethos has found its way to mobile development as well, in
React Native. React Native allows you to write native mobile
applications for iOS and Android in Javascript using React, by running a
Javascript thread alongside the native language (Objective C for iOS and
Java for Android). These threads communicate with each other through a
bridge, over which data and event notifications are passed. This allows
React Native to leverage the perfomance of native UI views and code for
computationally expensive operations, and to program less expensive
application logic on the Javascript thread through React. There are
potential benefits here for developer cognitive burden and experience,
just as in React for the web.

#+begin_html
  </p>
#+end_html

#+begin_html
  <p>
#+end_html

React and its contingent libraries are most interesting to me not as
ways to improve iteration or application stabilty in industry software
development (the standard evangelizations of React), but as a robust and
elegant philosophy for dealing with complexity. If there is anything I
can believe in, any concept of 'productivity' that seems worth striving
for, it is simplifying complexity. This is one of the reasons I like
programming; programming is the practice of using abstraction to manage
complex anatomies, often otherwise unassailable. This is possibly the
imperative of all thought we inscribe as meaningful--science,
philosophy, political science, literature, music--it all looks to
'explain': to rethink complex anatomies via 'simpler' abstractions,
thought configurations that are more sympathetic with the current river
of our consciousness5.

#+begin_html
  </p>
#+end_html

#+begin_html
  <div class="footnotes">
#+end_html

#+begin_html
  <hr>
#+end_html

#+begin_html
  <ol>
#+end_html

#+begin_html
  <li id="fn-1">
#+end_html

#+begin_html
  <p>
#+end_html

Shameless plug; this is my website after all.

#+begin_html
  </p>
#+end_html

↩

#+begin_html
  </li>
#+end_html

#+begin_html
  <li id="fn-3">
#+end_html

#+begin_html
  <p>
#+end_html

Programming languages have lots of interesting ways of abstracting time
(or asynchronous operation) for the developer, and Javascript is no
exception. The language's most recent specification, ES2015, includes
callbacks, promises and generators, to name a few.

#+begin_html
  </p>
#+end_html

↩

#+begin_html
  </li>
#+end_html

#+begin_html
  <li id="fn-4">
#+end_html

#+begin_html
  <p>
#+end_html

Note that React also provides a solution for storing and redistributing
data, the state of a React component. React components can hold state
and modify parts of the DOM within their own assigned territory; but the
core philosophy of React wants to defer most authority to a higher
truth. React component state is a capability that allows distribution of
authority within reasonable constraint. It's overwrought and possibly
melodramatic to defer every little update to a centralized control
station.

#+begin_html
  </p>
#+end_html

↩

#+begin_html
  </li>
#+end_html

#+begin_html
  <li id="fn-5">
#+end_html

#+begin_html
  <p>
#+end_html

Thanks to Daniel, Karina and Kevin for reviewing this article and
providing feedback.

#+begin_html
  </p>
#+end_html

↩

#+begin_html
  </li>
#+end_html

#+begin_html
  </ol>
#+end_html

#+begin_html
  </div>
#+end_html

#+begin_html
  </div>
#+end_html
